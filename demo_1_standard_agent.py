"""
Demo 1: Standard ReAct Agent with EPAM DIAL API
Shows how a traditional ReAct agent handles a research task
"""

import asyncio
import os
import time
from dotenv import load_dotenv
from langchain_openai import AzureChatOpenAI
from langchain.agents import create_react_agent, AgentExecutor
from langchain.prompts import PromptTemplate
from langchain.tools import tool
from langchain.callbacks import get_openai_callback
from utils import setup_environment, print_header, console, web_search

# Load environment variables
load_dotenv()

@tool
def search_web(query: str) -> str:
    """Search the web for information using DuckDuckGo"""
    return web_search(query)

@tool
def analyze_data(data: str) -> str:
    """Analyze and summarize data or information using LLM"""
    # Create a simple LLM client for analysis
    llm = AzureChatOpenAI(
        azure_deployment=os.getenv("MODEL_NAME", "gpt-4"),
        api_key=os.getenv("DIAL_API_KEY"),
        api_version=os.getenv("DIAL_API_VERSION", "2024-02-15-preview"),
        azure_endpoint=os.getenv("DIAL_API_URL"),
        temperature=0.1
    )
    
    analysis_prompt = f"""Analyze the following data and provide key insights:

Data to analyze:
{data}

Please provide:
1. Key themes and patterns
2. Important findings or insights
3. Relevance score (1-100)
4. Summary of main points

Format your response as a structured analysis."""

    try:
        result = llm.invoke(analysis_prompt)
        content = result.content if hasattr(result, 'content') else str(result)
        
        return f"""Standard Agent Analysis:
📊 Data Length: {len(data)} characters
🧠 LLM Analysis Results:
{content}"""
    except Exception as e:
        return f"Analysis error: {str(e)}. Falling back to basic analysis of {len(data)} characters."

@tool
def save_findings(content: str, filename: str = "research_notes.txt") -> str:
    """Save research findings to a file"""
    import os
    from datetime import datetime
    
    # Create timestamp
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Add basic header to content
    standard_content = f"""# Standard Agent Research Report
**Generated:** {timestamp}
**Agent:** Standard ReAct Agent with DIAL API
**Tools Used:** search_web, analyze_data, save_findings

---

{content}

---

**Report Generated by Standard ReAct Agent**
"""
    
    try:
        # Save to file
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(standard_content)
        
        return f"Findings saved to {filename}. Content length: {len(standard_content)} characters."
    except Exception as e:
        return f"Error saving file: {str(e)}"

def create_standard_agent():
    """Create a standard ReAct agent using DIAL API"""
    
    # Create DIAL API client
    llm = AzureChatOpenAI(
        azure_deployment=os.getenv("MODEL_NAME", "gpt-4"),
        api_key=os.getenv("DIAL_API_KEY"),
        api_version=os.getenv("DIAL_API_VERSION", "2024-02-15-preview"),
        azure_endpoint=os.getenv("DIAL_API_URL"),
        temperature=float(os.getenv("TEMPERATURE", "0.1"))
    )
    
    # Standard ReAct prompt
    react_prompt = PromptTemplate.from_template("""
Answer the following questions as best you can. You have access to the following tools:

{tools}

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin!

Question: {input}
Thought:{agent_scratchpad}
""")
    
    # Create tools list
    tools = [search_web, analyze_data, save_findings]
    
    # Create the ReAct agent
    agent = create_react_agent(llm, tools, react_prompt)
    
    # Create agent executor
    agent_executor = AgentExecutor(
        agent=agent, 
        tools=tools, 
        verbose=True,
        max_iterations=5,
        handle_parsing_errors=True
    )
    
    return agent_executor

async def main():
    print_header("DEMO 1: STANDARD REACT AGENT WITH DIAL API")
    
    # Setup environment
    if not setup_environment():
        return
    
    if console:
        console.print("🤖 Creating Standard ReAct Agent with DIAL API...")
        console.print("[dim]This agent uses traditional ReAct (Reasoning + Acting) pattern[/dim]\n")
    else:
        print("🤖 Creating Standard ReAct Agent with DIAL API...")
        print("This agent uses traditional ReAct (Reasoning + Acting) pattern\n")
    
    try:
        # Create standard agent
        agent = create_standard_agent()
        
        if console:
            console.print("✅ Standard ReAct Agent created successfully")
            console.print("📋 Available tools: search_web, analyze_data, save_findings\n")
        else:
            print("✅ Standard ReAct Agent created successfully")
            print("📋 Available tools: search_web, analyze_data, save_findings\n")
        
        # Same task as Deep Agent for fair comparison
        task = """Research the current applications of AI in healthcare. Please:
1. Search for recent information about AI healthcare applications
2. Analyze the key findings and trends
3. Create a structured report with your analysis
4. Include specific examples and benefits

Provide a comprehensive but focused analysis."""
        
        if console:
            console.print(f"[bold]📝 Task:[/bold] {task}\n")
            console.print("[yellow]🚀 Running Standard Agent...[/yellow]")
        else:
            print(f"📝 Task: {task}\n")
            print("🚀 Running Standard Agent...")
        
        # Start timing and token tracking
        start_time = time.time()
        
        # Execute the task with token tracking
        with get_openai_callback() as cb:
            result = agent.invoke({"input": task})
        
        # Calculate execution time
        end_time = time.time()
        execution_time = end_time - start_time
        
        # Display results
        if console:
            console.print("\n[bold green]✅ Standard Agent Results:[/bold green]")
            console.print("="*60)
            console.print(f"\n[bold]Final Answer:[/bold]\n{result['output']}")
            
            # Display metrics
            console.print(f"\n[bold blue]📊 Standard Agent Performance Metrics:[/bold blue]")
            console.print("="*60)
            console.print(f"⏱️  [bold]Execution Time:[/bold] {execution_time:.2f} seconds")
            console.print(f"🎯 [bold]Total Tokens:[/bold] {cb.total_tokens:,}")
            console.print(f"📤 [bold]Prompt Tokens:[/bold] {cb.prompt_tokens:,}")
            console.print(f"📥 [bold]Completion Tokens:[/bold] {cb.completion_tokens:,}")
            console.print(f"💰 [bold]Total Cost:[/bold] ${cb.total_cost:.4f}")
            
        else:
            print("\n✅ Standard Agent Results:")
            print("="*60)
            print(f"\nFinal Answer:\n{result['output']}")
            
            # Display metrics
            print(f"\n📊 Standard Agent Performance Metrics:")
            print("="*60)
            print(f"⏱️  Execution Time: {execution_time:.2f} seconds")
            print(f"🎯 Total Tokens: {cb.total_tokens:,}")
            print(f"📤 Prompt Tokens: {cb.prompt_tokens:,}")
            print(f"📥 Completion Tokens: {cb.completion_tokens:,}")
            print(f"💰 Total Cost: ${cb.total_cost:.4f}")
            
        # Display characteristics (common for both console and print)
        if console:
            console.print("\n[bold cyan]📊 Standard Agent Characteristics:[/bold cyan]")
            console.print("• Uses traditional ReAct (Reasoning + Acting) pattern")
            console.print("• Linear execution: Think → Act → Observe → Repeat")
            console.print("• Limited to immediate tool responses")
            console.print("• No persistence between sessions")
            console.print("• Basic tool coordination")
        else:
            print("\n📊 Standard Agent Characteristics:")
            print("• Uses traditional ReAct (Reasoning + Acting) pattern")
            print("• Linear execution: Think → Act → Observe → Repeat")
            print("• Limited to immediate tool responses")
            print("• No persistence between sessions")
            print("• Basic tool coordination")
    
    except Exception as e:
        if console:
            console.print(f"[red]❌ Error: {str(e)}[/red]")
            console.print("[yellow]Make sure you have proper DIAL API credentials in .env[/yellow]")
        else:
            print(f"❌ Error: {str(e)}")
            print("Make sure you have proper DIAL API credentials in .env")

if __name__ == "__main__":
    asyncio.run(main())